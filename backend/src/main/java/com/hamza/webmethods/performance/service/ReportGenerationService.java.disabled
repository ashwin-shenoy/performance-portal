package com.hamza.durandhar.performance.service;

import com.hamza.durandhar.performance.entity.*;
import com.hamza.durandhar.performance.repository.*;
import com.itextpdf.text.*;
import com.itextpdf.text.pdf.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for generating comprehensive technical reports with architecture diagrams and test cases
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class ReportGenerationService {

    private final TestRunRepository testRunRepository;
    private final TestArtifactRepository testArtifactRepository;
    private final TestMetricRepository testMetricRepository;
    private final TestTransactionRepository testTransactionRepository;

    @Value("${app.reports.dir:reports}")
    private String reportsDirectory;

    private static final Font TITLE_FONT = new Font(Font.FontFamily.HELVETICA, 24, Font.BOLD, BaseColor.DARK_GRAY);
    private static final Font HEADING_FONT = new Font(Font.FontFamily.HELVETICA, 18, Font.BOLD, BaseColor.BLACK);
    private static final Font SUBHEADING_FONT = new Font(Font.FontFamily.HELVETICA, 14, Font.BOLD, BaseColor.BLACK);
    private static final Font NORMAL_FONT = new Font(Font.FontFamily.HELVETICA, 11, Font.NORMAL, BaseColor.BLACK);
    private static final Font SMALL_FONT = new Font(Font.FontFamily.HELVETICA, 9, Font.NORMAL, BaseColor.DARK_GRAY);
    private static final Font TABLE_HEADER_FONT = new Font(Font.FontFamily.HELVETICA, 10, Font.BOLD, BaseColor.WHITE);
    private static final Font TABLE_CELL_FONT = new Font(Font.FontFamily.HELVETICA, 9, Font.NORMAL, BaseColor.BLACK);

    /**
     * Generate comprehensive technical report with all sections
     */
    @Transactional(readOnly = true)
    public Report generateTechnicalReport(Long testRunId, String generatedBy) throws DocumentException, IOException {
        log.info("Generating technical report for test run ID: {}", testRunId);

        // Fetch all required data
        TestRun testRun = testRunRepository.findById(testRunId)
                .orElseThrow(() -> new RuntimeException("Test run not found: " + testRunId));
        
        List<TestArtifact> artifacts = testArtifactRepository.findByTestRunId(testRunId);
        // TestCase removed as per master plan
        List<TestMetric> metrics = testMetricRepository.findByTestRunId(testRunId);
        List<TestTransaction> transactions = testTransactionRepository.findByTestRunId(testRunId);

        // Create report directory if not exists
        Path reportDir = Paths.get(reportsDirectory);
        if (!Files.exists(reportDir)) {
            Files.createDirectories(reportDir);
        }

        // Generate report filename
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        String fileName = String.format("Technical_Report_%s_%s.pdf", testRun.getTestName().replaceAll("\\s+", "_"), timestamp);
        String filePath = reportDir.resolve(fileName).toString();

        // Create PDF document
        Document document = new Document(PageSize.A4, 50, 50, 50, 50);
        PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(filePath));
        
        // Add page numbers and headers
        writer.setPageEvent(new ReportHeaderFooter(testRun));
        
        document.open();

        try {
            // 1. Cover Page
            addCoverPage(document, testRun);
            document.newPage();

            // 2. Executive Summary
            addExecutiveSummary(document, testRun, metrics, testCases);
            document.newPage();

            // 3. System Architecture (if available)
            Optional<TestArtifact> architectureDiagram = artifacts.stream()
                    .filter(a -> a.getArtifactType() == TestArtifact.ArtifactType.ARCHITECTURE_DIAGRAM)
                    .findFirst();
            
            if (architectureDiagram.isPresent()) {
                addArchitectureSection(document, architectureDiagram.get());
                document.newPage();
            }

            // 4. Test Configuration
            addTestConfiguration(document, testRun);
            document.newPage();

            // 5. Test Cases Summary (if available)
            if (!testCases.isEmpty()) {
                addTestCasesSummary(document, testCases);
                document.newPage();
            }

            // 6. Performance Results
            addPerformanceResults(document, metrics, transactions);
            document.newPage();

            // 7. Transaction Analysis
            addTransactionAnalysis(document, transactions);
            document.newPage();

            // 8. Analysis & Recommendations
            addAnalysisAndRecommendations(document, metrics, transactions, testCases);
            document.newPage();

            // 9. Appendix
            addAppendix(document, transactions, testCases);

        } finally {
            document.close();
        }

        // Save report metadata
        Report report = Report.builder()
                .testRun(testRun)
                .reportType(Report.ReportType.TECHNICAL_PDF)
                .fileName(fileName)
                .filePath(filePath)
                .fileSize(Files.size(Paths.get(filePath)))
                .generatedBy(generatedBy)
                .description("Comprehensive technical report with architecture and test cases")
                .build();

        log.info("Technical report generated successfully: {}", filePath);
        return report;
    }

    /**
     * Add cover page
     */
    private void addCoverPage(Document document, TestRun testRun) throws DocumentException {
        Paragraph title = new Paragraph("Performance Test Report", TITLE_FONT);
        title.setAlignment(Element.ALIGN_CENTER);
        title.setSpacingAfter(30);
        document.add(title);

        // Add logo placeholder or company name
        Paragraph company = new Paragraph("Hamza durandhar Performance Portal", HEADING_FONT);
        company.setAlignment(Element.ALIGN_CENTER);
        company.setSpacingAfter(50);
        document.add(company);

        // Test details
        PdfPTable infoTable = new PdfPTable(2);
        infoTable.setWidthPercentage(70);
        infoTable.setHorizontalAlignment(Element.ALIGN_CENTER);
        infoTable.setSpacingBefore(50);
        infoTable.setSpacingAfter(30);

        addInfoRow(infoTable, "Capability:", testRun.getCapability().getName());
        addInfoRow(infoTable, "Test Name:", testRun.getTestName());
        addInfoRow(infoTable, "Test Date:", testRun.getTestDate().toString());
        addInfoRow(infoTable, "Report Generated:", LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
        addInfoRow(infoTable, "Status:", testRun.getStatus().toString());

        document.add(infoTable);

        // Add summary badges
        if (testRun.getHasArchitectureDiagram()) {
            Paragraph badge1 = new Paragraph("✓ Includes Architecture Diagram", NORMAL_FONT);
            badge1.setAlignment(Element.ALIGN_CENTER);
            document.add(badge1);
        }
        if (testRun.getHasTestCasesSummary()) {
            Paragraph badge2 = new Paragraph("✓ Includes Test Cases Summary", NORMAL_FONT);
            badge2.setAlignment(Element.ALIGN_CENTER);
            document.add(badge2);
        }
    }

    /**
     * Add executive summary
     */
    private void addExecutiveSummary(Document document, TestRun testRun, List<TestMetric> metrics, List<TestCase> testCases) throws DocumentException {
        addSectionTitle(document, "Executive Summary");

        // Key findings
        Paragraph intro = new Paragraph(
            String.format("This report presents the performance test results for %s conducted on %s. " +
                         "The test evaluated system performance under various load conditions.",
                         testRun.getCapability().getName(), testRun.getTestDate()),
            NORMAL_FONT
        );
        intro.setSpacingAfter(15);
        document.add(intro);

        // Performance highlights - use TestRun aggregated data
        if (testRun.getAvgResponseTime() != null) {
            addSubheading(document, "Performance Highlights");
            
            com.itextpdf.text.List list = new com.itextpdf.text.List(com.itextpdf.text.List.UNORDERED);
            list.add(new ListItem(String.format("Average Response Time: %.2f ms", testRun.getAvgResponseTime()), NORMAL_FONT));
            if (testRun.getThroughput() != null) {
                list.add(new ListItem(String.format("Throughput: %.2f requests/sec", testRun.getThroughput()), NORMAL_FONT));
            }
            if (testRun.getErrorRate() != null) {
                list.add(new ListItem(String.format("Error Rate: %.2f%%", testRun.getErrorRate()), NORMAL_FONT));
            }
            if (testRun.getTotalRequests() != null) {
                list.add(new ListItem(String.format("Total Requests: %d", testRun.getTotalRequests()), NORMAL_FONT));
            }
            document.add(list);
        }

        // Test cases summary
        if (!testCases.isEmpty()) {
            addSubheading(document, "Test Coverage Summary");
            
            Map<String, Long> statusCounts = testCases.stream()
                    .collect(Collectors.groupingBy(tc -> tc.getStatus().toString(), Collectors.counting()));
            
            long passed = statusCounts.getOrDefault("PASS", 0L);
            long failed = statusCounts.getOrDefault("FAIL", 0L);
            double passRate = testCases.isEmpty() ? 0 : (passed * 100.0 / testCases.size());

            com.itextpdf.text.List tcList = new com.itextpdf.text.List(com.itextpdf.text.List.UNORDERED);
            tcList.add(new ListItem(String.format("Total Test Cases: %d", testCases.size()), NORMAL_FONT));
            tcList.add(new ListItem(String.format("Passed: %d (%.1f%%)", passed, passRate), NORMAL_FONT));
            tcList.add(new ListItem(String.format("Failed: %d", failed), NORMAL_FONT));
            document.add(tcList);
        }
    }

    /**
     * Add architecture section with diagram
     */
    private void addArchitectureSection(Document document, TestArtifact architectureDiagram) throws DocumentException, IOException {
        addSectionTitle(document, "System Architecture");

        Paragraph intro = new Paragraph(
            "The following diagram illustrates the system architecture and components involved in this performance test.",
            NORMAL_FONT
        );
        intro.setSpacingAfter(15);
        document.add(intro);

        // Embed architecture diagram
        try {
            Image image = Image.getInstance(architectureDiagram.getFilePath());
            
            // Scale image to fit page width while maintaining aspect ratio
            float maxWidth = document.getPageSize().getWidth() - document.leftMargin() - document.rightMargin();
            float maxHeight = 400f;
            
            if (image.getWidth() > maxWidth) {
                float scaleFactor = maxWidth / image.getWidth();
                image.scalePercent(scaleFactor * 100);
            }
            
            if (image.getScaledHeight() > maxHeight) {
                float scaleFactor = maxHeight / image.getScaledHeight();
                image.scalePercent(image.getScaledWidth() * scaleFactor / image.getWidth() * 100);
            }
            
            image.setAlignment(Element.ALIGN_CENTER);
            image.setSpacingBefore(10);
            image.setSpacingAfter(10);
            document.add(image);

            // Add caption
            Paragraph caption = new Paragraph("Figure 1: System Architecture Diagram", SMALL_FONT);
            caption.setAlignment(Element.ALIGN_CENTER);
            caption.setSpacingAfter(15);
            document.add(caption);

        } catch (Exception e) {
            log.error("Failed to embed architecture diagram: {}", e.getMessage());
            Paragraph error = new Paragraph("Architecture diagram could not be embedded.", NORMAL_FONT);
            error.setSpacingAfter(15);
            document.add(error);
        }

        // Add architecture metadata if available
        if (architectureDiagram.getMetadata() != null && !architectureDiagram.getMetadata().isEmpty()) {
            addSubheading(document, "Architecture Details");
            
            Map<String, Object> metadata = architectureDiagram.getMetadata();
            Paragraph details = new Paragraph();
            details.setFont(NORMAL_FONT);
            
            if (metadata.containsKey("width") && metadata.containsKey("height")) {
                details.add(String.format("Diagram Dimensions: %s x %s pixels\n", 
                    metadata.get("width"), metadata.get("height")));
            }
            if (metadata.containsKey("format")) {
                details.add(String.format("Format: %s\n", metadata.get("format")));
            }
            
            document.add(details);
        }
    }

    /**
     * Add test configuration section
     */
    private void addTestConfiguration(Document document, TestRun testRun) throws DocumentException {
        addSectionTitle(document, "Test Configuration");

        PdfPTable table = new PdfPTable(2);
        table.setWidthPercentage(100);
        table.setSpacingBefore(10);
        table.setSpacingAfter(15);
        table.setWidths(new float[]{1, 2});

        addConfigRow(table, "Test Name", testRun.getTestName());
        addConfigRow(table, "Capability", testRun.getCapability().getName());
        addConfigRow(table, "Test Date", testRun.getTestDate().toString());
        addConfigRow(table, "Test Duration", testRun.getTestDurationSeconds() != null ? testRun.getTestDurationSeconds() + " seconds" : "N/A");
        addConfigRow(table, "Virtual Users", testRun.getVirtualUsers() != null ? testRun.getVirtualUsers().toString() : "N/A");
        addConfigRow(table, "File Name", testRun.getFileName());
        addConfigRow(table, "Uploaded By", testRun.getUploadedBy());

        document.add(table);

        if (testRun.getDescription() != null && !testRun.getDescription().isEmpty()) {
            addSubheading(document, "Test Description");
            Paragraph desc = new Paragraph(testRun.getDescription(), NORMAL_FONT);
            desc.setSpacingAfter(15);
            document.add(desc);
        }
    }

    /**
     * Add test cases summary section
     */
    private void addTestCasesSummary(Document document, List<TestCase> testCases) throws DocumentException {
        addSectionTitle(document, "Test Cases Summary");

        // Calculate statistics
        Map<String, Long> statusCounts = testCases.stream()
                .collect(Collectors.groupingBy(tc -> tc.getStatus().toString(), Collectors.counting()));
        
        Map<String, Long> categoryCounts = testCases.stream()
                .filter(tc -> tc.getCategory() != null)
                .collect(Collectors.groupingBy(TestCase::getCategory, Collectors.counting()));

        long passed = statusCounts.getOrDefault("PASS", 0L);
        long failed = statusCounts.getOrDefault("FAIL", 0L);
        long skipped = statusCounts.getOrDefault("SKIP", 0L);
        long blocked = statusCounts.getOrDefault("BLOCKED", 0L);
        double passRate = testCases.isEmpty() ? 0 : (passed * 100.0 / testCases.size());

        // Statistics overview
        addSubheading(document, "Test Coverage Overview");
        
        PdfPTable statsTable = new PdfPTable(4);
        statsTable.setWidthPercentage(100);
        statsTable.setSpacingBefore(10);
        statsTable.setSpacingAfter(15);

        // Header
        addStatsHeaderCell(statsTable, "Total");
        addStatsHeaderCell(statsTable, "Passed");
        addStatsHeaderCell(statsTable, "Failed");
        addStatsHeaderCell(statsTable, "Pass Rate");

        // Data
        addStatsCellCenter(statsTable, String.valueOf(testCases.size()));
        addStatsCellCenter(statsTable, String.valueOf(passed), BaseColor.GREEN);
        addStatsCellCenter(statsTable, String.valueOf(failed), failed > 0 ? BaseColor.RED : BaseColor.BLACK);
        addStatsCellCenter(statsTable, String.format("%.1f%%", passRate));

        document.add(statsTable);

        // Category breakdown
        if (!categoryCounts.isEmpty()) {
            addSubheading(document, "Test Cases by Category");
            
            PdfPTable categoryTable = new PdfPTable(3);
            categoryTable.setWidthPercentage(80);
            categoryTable.setSpacingBefore(10);
            categoryTable.setSpacingAfter(15);
            categoryTable.setWidths(new float[]{2, 1, 1});

            addTableHeaderCell(categoryTable, "Category");
            addTableHeaderCell(categoryTable, "Count");
            addTableHeaderCell(categoryTable, "Percentage");

            categoryCounts.entrySet().stream()
                    .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
                    .forEach(entry -> {
                        addTableCell(categoryTable, entry.getKey());
                        addTableCellCenter(categoryTable, String.valueOf(entry.getValue()));
                        addTableCellCenter(categoryTable, String.format("%.1f%%", entry.getValue() * 100.0 / testCases.size()));
                    });

            document.add(categoryTable);
        }

        // Detailed test cases table
        addSubheading(document, "Detailed Test Cases");
        
        PdfPTable detailTable = new PdfPTable(6);
        detailTable.setWidthPercentage(100);
        detailTable.setSpacingBefore(10);
        detailTable.setSpacingAfter(15);
        detailTable.setWidths(new float[]{0.8f, 2.5f, 1.2f, 0.8f, 0.8f, 1f});

        addTableHeaderCell(detailTable, "ID");
        addTableHeaderCell(detailTable, "Test Case Name");
        addTableHeaderCell(detailTable, "Category");
        addTableHeaderCell(detailTable, "Priority");
        addTableHeaderCell(detailTable, "Status");
        addTableHeaderCell(detailTable, "Time (ms)");

        // Add test cases (limit to first 50 for readability)
        testCases.stream()
                .limit(50)
                .forEach(tc -> {
                    addTableCell(detailTable, tc.getTestCaseId() != null ? tc.getTestCaseId() : "-");
                    addTableCell(detailTable, tc.getTestCaseName());
                    addTableCell(detailTable, tc.getCategory() != null ? tc.getCategory() : "-");
                    addTableCell(detailTable, tc.getPriority() != null ? tc.getPriority().toString() : "-");
                    
                    BaseColor statusColor = getStatusColor(tc.getStatus());
                    addTableCellWithColor(detailTable, tc.getStatus().toString(), statusColor);
                    
                    addTableCellRight(detailTable, tc.getExecutionTime() != null ? tc.getExecutionTime().toString() : "-");
                });

        document.add(detailTable);

        if (testCases.size() > 50) {
            Paragraph note = new Paragraph(
                String.format("Note: Showing first 50 of %d test cases. See appendix for complete list.", testCases.size()),
                SMALL_FONT
            );
            note.setSpacingAfter(10);
            document.add(note);
        }
    }

    /**
     * Add performance results section
     */
    private void addPerformanceResults(Document document, List<TestMetric> metrics, List<TestTransaction> transactions) throws DocumentException {
        addSectionTitle(document, "Performance Results");

        // Get test run from the first transaction (we need it for aggregated data)
        TestRun testRun = !transactions.isEmpty() ? transactions.get(0).getTestRun() : null;
        
        if (testRun == null || testRun.getAvgResponseTime() == null) {
            Paragraph noData = new Paragraph("No performance metrics available.", NORMAL_FONT);
            document.add(noData);
            return;
        }

        // Summary metrics table using TestRun aggregated data
        addSubheading(document, "Performance Metrics Summary");
        
        PdfPTable metricsTable = new PdfPTable(5);
        metricsTable.setWidthPercentage(100);
        metricsTable.setSpacingBefore(10);
        metricsTable.setSpacingAfter(15);

        addTableHeaderCell(metricsTable, "Metric");
        addTableHeaderCell(metricsTable, "Average");
        addTableHeaderCell(metricsTable, "Minimum");
        addTableHeaderCell(metricsTable, "Maximum");
        addTableHeaderCell(metricsTable, "Value");

        // Response Time
        addTableCell(metricsTable, "Response Time (ms)");
        addTableCellRight(metricsTable, String.format("%.2f", testRun.getAvgResponseTime()));
        addTableCellRight(metricsTable, testRun.getMinResponseTime() != null ? String.format("%.2f", testRun.getMinResponseTime()) : "-");
        addTableCellRight(metricsTable, testRun.getMaxResponseTime() != null ? String.format("%.2f", testRun.getMaxResponseTime()) : "-");
        addTableCellRight(metricsTable, "-");

        // Throughput
        addTableCell(metricsTable, "Throughput (req/s)");
        addTableCellRight(metricsTable, testRun.getThroughput() != null ? String.format("%.2f", testRun.getThroughput()) : "-");
        addTableCellRight(metricsTable, "-");
        addTableCellRight(metricsTable, "-");
        addTableCellRight(metricsTable, "-");

        // Error Rate
        addTableCell(metricsTable, "Error Rate (%)");
        addTableCellRight(metricsTable, testRun.getErrorRate() != null ? String.format("%.2f", testRun.getErrorRate()) : "-");
        addTableCellRight(metricsTable, "-");
        addTableCellRight(metricsTable, "-");
        addTableCellRight(metricsTable, "-");

        // Total Requests
        addTableCell(metricsTable, "Total Requests");
        addTableCellRight(metricsTable, "-");
        addTableCellRight(metricsTable, "-");
        addTableCellRight(metricsTable, "-");
        addTableCellRight(metricsTable, testRun.getTotalRequests() != null ? String.valueOf(testRun.getTotalRequests()) : "-");

        document.add(metricsTable);

        // Key observations
        addSubheading(document, "Key Observations");
        
        com.itextpdf.text.List observations = new com.itextpdf.text.List(com.itextpdf.text.List.UNORDERED);
        observations.add(new ListItem(
            String.format("Average response time: %.2f ms", testRun.getAvgResponseTime()),
            NORMAL_FONT
        ));
        if (testRun.getThroughput() != null) {
            observations.add(new ListItem(
                String.format("System throughput: %.2f requests per second", testRun.getThroughput()),
                NORMAL_FONT
            ));
        }
        if (testRun.getErrorRate() != null && testRun.getTotalRequests() != null) {
            long errorCount = (long)(testRun.getErrorRate() * testRun.getTotalRequests() / 100);
            observations.add(new ListItem(
                String.format("Error rate: %.2f%% (%d errors out of %d requests)",
                    testRun.getErrorRate(), errorCount, testRun.getTotalRequests()),
                NORMAL_FONT
            ));
        }
        
        document.add(observations);
    }

    /**
     * Add transaction analysis section
     */
    private void addTransactionAnalysis(Document document, List<TestTransaction> transactions) throws DocumentException {
        addSectionTitle(document, "Transaction Analysis");

        if (transactions.isEmpty()) {
            Paragraph noData = new Paragraph("No transaction data available.", NORMAL_FONT);
            document.add(noData);
            return;
        }

        // Calculate aggregated statistics per transaction name
        Map<String, TransactionStats> transactionStatsMap = calculateTransactionStats(transactions);

        addSubheading(document, "Top Transactions by Response Time");
        
        PdfPTable transTable = new PdfPTable(6);
        transTable.setWidthPercentage(100);
        transTable.setSpacingBefore(10);
        transTable.setSpacingAfter(15);

        addTableHeaderCell(transTable, "Transaction Name");
        addTableHeaderCell(transTable, "Avg Response (ms)");
        addTableHeaderCell(transTable, "Min (ms)");
        addTableHeaderCell(transTable, "Max (ms)");
        addTableHeaderCell(transTable, "Samples");
        addTableHeaderCell(transTable, "Errors");

        transactionStatsMap.entrySet().stream()
                .sorted(Map.Entry.<String, TransactionStats>comparingByValue(
                    Comparator.comparing(TransactionStats::getAvgResponseTime).reversed()))
                .limit(20)
                .forEach(entry -> {
                    TransactionStats stats = entry.getValue();
                    addTableCell(transTable, entry.getKey());
                    addTableCellRight(transTable, String.format("%.2f", stats.getAvgResponseTime()));
                    addTableCellRight(transTable, String.format("%d", stats.getMinResponseTime()));
                    addTableCellRight(transTable, String.format("%d", stats.getMaxResponseTime()));
                    addTableCellRight(transTable, String.valueOf(stats.getSampleCount()));
                    addTableCellRight(transTable, String.valueOf(stats.getErrorCount()));
                });

        document.add(transTable);
    }

    /**
     * Calculate aggregated statistics per transaction name
     */
    private Map<String, TransactionStats> calculateTransactionStats(List<TestTransaction> transactions) {
        return transactions.stream()
                .collect(Collectors.groupingBy(
                        TestTransaction::getTransactionName,
                        Collectors.collectingAndThen(
                                Collectors.toList(),
                                list -> {
                                    long count = list.size();
                                    double avgResponseTime = list.stream()
                                            .mapToLong(TestTransaction::getResponseTime)
                                            .average()
                                            .orElse(0.0);
                                    long minResponseTime = list.stream()
                                            .mapToLong(TestTransaction::getResponseTime)
                                            .min()
                                            .orElse(0L);
                                    long maxResponseTime = list.stream()
                                            .mapToLong(TestTransaction::getResponseTime)
                                            .max()
                                            .orElse(0L);
                                    long errorCount = list.stream()
                                            .filter(t -> !t.getSuccess())
                                            .count();
                                    
                                    return new TransactionStats(count, avgResponseTime, minResponseTime,
                                            maxResponseTime, errorCount);
                                }
                        )
                ));
    }

    /**
     * Inner class to hold transaction statistics
     */
    private static class TransactionStats {
        private final long sampleCount;
        private final double avgResponseTime;
        private final long minResponseTime;
        private final long maxResponseTime;
        private final long errorCount;

        public TransactionStats(long sampleCount, double avgResponseTime, long minResponseTime,
                               long maxResponseTime, long errorCount) {
            this.sampleCount = sampleCount;
            this.avgResponseTime = avgResponseTime;
            this.minResponseTime = minResponseTime;
            this.maxResponseTime = maxResponseTime;
            this.errorCount = errorCount;
        }

        public long getSampleCount() { return sampleCount; }
        public double getAvgResponseTime() { return avgResponseTime; }
        public long getMinResponseTime() { return minResponseTime; }
        public long getMaxResponseTime() { return maxResponseTime; }
        public long getErrorCount() { return errorCount; }
    }

    /**
     * Add analysis and recommendations section
     */
    private void addAnalysisAndRecommendations(Document document, List<TestMetric> metrics,
                                               List<TestTransaction> transactions, List<TestCase> testCases) throws DocumentException {
        addSectionTitle(document, "Analysis & Recommendations");

        addSubheading(document, "Performance Analysis");
        
        com.itextpdf.text.List analysis = new com.itextpdf.text.List(com.itextpdf.text.List.UNORDERED);
        
        // Get test run from transactions
        TestRun testRun = !transactions.isEmpty() ? transactions.get(0).getTestRun() : null;
        
        if (testRun != null) {
            if (testRun.getErrorRate() != null && testRun.getErrorRate() > 5.0) {
                analysis.add(new ListItem(
                    "High error rate detected. Investigation required for error causes.",
                    NORMAL_FONT
                ));
            }
            
            if (testRun.getAvgResponseTime() != null && testRun.getAvgResponseTime() > 1000) {
                analysis.add(new ListItem(
                    "Response times exceed 1 second. Consider performance optimization.",
                    NORMAL_FONT
                ));
            }
        }

        if (!testCases.isEmpty()) {
            long failed = testCases.stream().filter(tc -> tc.getStatus() == TestCase.Status.FAIL).count();
            if (failed > 0) {
                analysis.add(new ListItem(
                    String.format("%d test case(s) failed. Review failed test cases for issues.", failed),
                    NORMAL_FONT
                ));
            }
        }

        if (analysis.isEmpty()) {
            analysis.add(new ListItem("System performance is within acceptable limits.", NORMAL_FONT));
        }

        document.add(analysis);

        addSubheading(document, "Recommendations");
        
        com.itextpdf.text.List recommendations = new com.itextpdf.text.List(com.itextpdf.text.List.ORDERED);
        recommendations.add(new ListItem("Monitor system performance under sustained load", NORMAL_FONT));
        recommendations.add(new ListItem("Implement caching strategies for frequently accessed data", NORMAL_FONT));
        recommendations.add(new ListItem("Review and optimize slow transactions", NORMAL_FONT));
        recommendations.add(new ListItem("Conduct stress testing to identify breaking points", NORMAL_FONT));
        
        document.add(recommendations);
    }

    /**
     * Add appendix section
     */
    private void addAppendix(Document document, List<TestTransaction> transactions, List<TestCase> testCases) throws DocumentException {
        addSectionTitle(document, "Appendix");

        addSubheading(document, "Complete Transaction List");
        
        if (!transactions.isEmpty()) {
            // Calculate aggregated statistics per transaction name
            Map<String, TransactionStats> transactionStatsMap = calculateTransactionStats(transactions);
            
            PdfPTable appendixTable = new PdfPTable(5);
            appendixTable.setWidthPercentage(100);
            appendixTable.setSpacingBefore(10);
            appendixTable.setSpacingAfter(15);

            addTableHeaderCell(appendixTable, "Transaction");
            addTableHeaderCell(appendixTable, "Avg (ms)");
            addTableHeaderCell(appendixTable, "Min (ms)");
            addTableHeaderCell(appendixTable, "Max (ms)");
            addTableHeaderCell(appendixTable, "Errors");

            transactionStatsMap.forEach((name, stats) -> {
                addTableCell(appendixTable, name);
                addTableCellRight(appendixTable, String.format("%.2f", stats.getAvgResponseTime()));
                addTableCellRight(appendixTable, String.format("%d", stats.getMinResponseTime()));
                addTableCellRight(appendixTable, String.format("%d", stats.getMaxResponseTime()));
                addTableCellRight(appendixTable, String.valueOf(stats.getErrorCount()));
            });

            document.add(appendixTable);
        }

        // Complete test cases list if more than 50
        if (testCases.size() > 50) {
            document.newPage();
            addSubheading(document, "Complete Test Cases List");
            
            PdfPTable tcTable = new PdfPTable(4);
            tcTable.setWidthPercentage(100);
            tcTable.setSpacingBefore(10);

            addTableHeaderCell(tcTable, "ID");
            addTableHeaderCell(tcTable, "Name");
            addTableHeaderCell(tcTable, "Category");
            addTableHeaderCell(tcTable, "Status");

            testCases.forEach(tc -> {
                addTableCell(tcTable, tc.getTestCaseId() != null ? tc.getTestCaseId() : "-");
                addTableCell(tcTable, tc.getTestCaseName());
                addTableCell(tcTable, tc.getCategory() != null ? tc.getCategory() : "-");
                addTableCellWithColor(tcTable, tc.getStatus().toString(), getStatusColor(tc.getStatus()));
            });

            document.add(tcTable);
        }
    }

    // Helper methods for table formatting

    private void addSectionTitle(Document document, String title) throws DocumentException {
        Paragraph section = new Paragraph(title, HEADING_FONT);
        section.setSpacingBefore(20);
        section.setSpacingAfter(15);
        document.add(section);
    }

    private void addSubheading(Document document, String title) throws DocumentException {
        Paragraph subheading = new Paragraph(title, SUBHEADING_FONT);
        subheading.setSpacingBefore(15);
        subheading.setSpacingAfter(10);
        document.add(subheading);
    }

    private void addInfoRow(PdfPTable table, String label, String value) {
        PdfPCell labelCell = new PdfPCell(new Phrase(label, SUBHEADING_FONT));
        labelCell.setBorder(Rectangle.NO_BORDER);
        labelCell.setPadding(5);
        table.addCell(labelCell);

        PdfPCell valueCell = new PdfPCell(new Phrase(value, NORMAL_FONT));
        valueCell.setBorder(Rectangle.NO_BORDER);
        valueCell.setPadding(5);
        table.addCell(valueCell);
    }

    private void addConfigRow(PdfPTable table, String label, String value) {
        PdfPCell labelCell = new PdfPCell(new Phrase(label, SUBHEADING_FONT));
        labelCell.setBackgroundColor(BaseColor.LIGHT_GRAY);
        labelCell.setPadding(5);
        table.addCell(labelCell);

        PdfPCell valueCell = new PdfPCell(new Phrase(value, NORMAL_FONT));
        valueCell.setPadding(5);
        table.addCell(valueCell);
    }

    private void addTableHeaderCell(PdfPTable table, String text) {
        PdfPCell cell = new PdfPCell(new Phrase(text, TABLE_HEADER_FONT));
        cell.setBackgroundColor(new BaseColor(41, 128, 185));
        cell.setHorizontalAlignment(Element.ALIGN_CENTER);
        cell.setPadding(8);
        table.addCell(cell);
    }

    private void addStatsHeaderCell(PdfPTable table, String text) {
        PdfPCell cell = new PdfPCell(new Phrase(text, TABLE_HEADER_FONT));
        cell.setBackgroundColor(new BaseColor(52, 73, 94));
        cell.setHorizontalAlignment(Element.ALIGN_CENTER);
        cell.setPadding(10);
        table.addCell(cell);
    }

    private void addTableCell(PdfPTable table, String text) {
        PdfPCell cell = new PdfPCell(new Phrase(text, TABLE_CELL_FONT));
        cell.setPadding(5);
        table.addCell(cell);
    }

    private void addTableCellCenter(PdfPTable table, String text) {
        PdfPCell cell = new PdfPCell(new Phrase(text, TABLE_CELL_FONT));
        cell.setHorizontalAlignment(Element.ALIGN_CENTER);
        cell.setPadding(5);
        table.addCell(cell);
    }

    private void addTableCellRight(PdfPTable table, String text) {
        PdfPCell cell = new PdfPCell(new Phrase(text, TABLE_CELL_FONT));
        cell.setHorizontalAlignment(Element.ALIGN_RIGHT);
        cell.setPadding(5);
        table.addCell(cell);
    }

    private void addTableCellWithColor(PdfPTable table, String text, BaseColor color) {
        Font colorFont = new Font(TABLE_CELL_FONT);
        colorFont.setColor(color);
        PdfPCell cell = new PdfPCell(new Phrase(text, colorFont));
        cell.setHorizontalAlignment(Element.ALIGN_CENTER);
        cell.setPadding(5);
        table.addCell(cell);
    }

    private void addStatsCellCenter(PdfPTable table, String text) {
        addStatsCellCenter(table, text, BaseColor.BLACK);
    }

    private void addStatsCellCenter(PdfPTable table, String text, BaseColor color) {
        Font font = new Font(SUBHEADING_FONT);
        font.setColor(color);
        PdfPCell cell = new PdfPCell(new Phrase(text, font));
        cell.setHorizontalAlignment(Element.ALIGN_CENTER);
        cell.setPadding(10);
        table.addCell(cell);
    }

    private BaseColor getStatusColor(TestCase.Status status) {
        return switch (status) {
            case PASS -> new BaseColor(39, 174, 96);
            case FAIL -> new BaseColor(231, 76, 60);
            case SKIP -> new BaseColor(241, 196, 15);
            case BLOCKED -> new BaseColor(149, 165, 166);
            default -> BaseColor.BLACK;
        };
    }

    /**
     * Inner class for page headers and footers
     */
    private static class ReportHeaderFooter extends PdfPageEventHelper {
        private final TestRun testRun;

        public ReportHeaderFooter(TestRun testRun) {
            this.testRun = testRun;
        }

        @Override
        public void onEndPage(PdfWriter writer, Document document) {
            PdfContentByte cb = writer.getDirectContent();
            
            // Header
            Phrase header = new Phrase(
                String.format("%s - Performance Test Report", testRun.getCapability().getName()),
                SMALL_FONT
            );
            ColumnText.showTextAligned(cb, Element.ALIGN_LEFT,
                header,
                document.left(), document.top() + 20, 0);

            // Footer with page number
            Phrase footer = new Phrase(
                String.format("Page %d", writer.getPageNumber()),
                SMALL_FONT
            );
            ColumnText.showTextAligned(cb, Element.ALIGN_CENTER,
                footer,
                (document.right() + document.left()) / 2,
                document.bottom() - 20, 0);
        }
    }
}

// Made with Bob